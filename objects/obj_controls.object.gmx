<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init

// Are we moving the palyer ?
move = false;
samePointCount = 0;

// The map of shapes
shapes = ds_map_create();

// 0 =&gt; fire
fire = ds_list_create();
ds_map_add(shapes,0,fire);

// 1 =&gt; left
left = ds_list_create();
ds_list_add(left, 180);
ds_map_add(shapes,1,left);

// 2 =&gt; up
up = ds_list_create();
ds_list_add(up, 90);
ds_map_add(shapes,2,up);

// 3 =&gt; down
down = ds_list_create();
ds_list_add(down, 270);
ds_map_add(shapes,3,down);

// shapes count
shapesCount = ds_map_size(shapes);

// The current shape
shape = ds_list_create();

// The current queue of points
pointsX = ds_queue_create(); 
pointsY = ds_queue_create(); 

// All the points drawn by the user
allX = ds_list_create(); 
allY = ds_list_create(); 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clean

// The map of shapes
ds_map_destroy(shapes);

ds_list_destroy(fire);
ds_list_destroy(left);
ds_list_destroy(up);
ds_list_destroy(down);

// The current shape
ds_list_destroy(shape);

// The current queue of points
ds_queue_destroy(pointsX); 
ds_queue_destroy(pointsY); 

// All the points drawn by the user
ds_list_destroy(allX);
ds_list_destroy(allY);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Compute shape made by the user
// if the player moved EDE, no need to do something else
show_debug_message("Released " + string(move));
if (!move){
    show_debug_message(scr_listToString(shape));
    
    // The shape size, changes after sampling
    var shapeSize; 
    shapeSize = ds_list_size(shape);
    
    // The user drawn shape current angle index (used in various for loops)
    var currentAngleIndex; 
    
    // filter the shape ! 
    // The sampled shape [0, 0, 0, 0, 270, 180, 180, 180] =&gt; [0,180]
    var sampledShape; sampledShape = ds_list_create();
    // How many times did we meet the same angle ?
    var sameAngleCount; sameAngleCount = 0;
    // Last angle
    var lastAngle; lastAngle = -1;
    // current angle
    var currentAngle; currentAngle = -1;
    
    for (currentAngleIndex = 0; currentAngleIndex &lt; shapeSize; currentAngleIndex += 1){
        currentAngle = ds_list_find_value(shape,currentAngleIndex);
        if (currentAngle == lastAngle){
            sameAngleCount += 1;
            if (sameAngleCount == CTRL_ANGLE_SAMPLING_COUNT){
                ds_list_add(sampledShape,currentAngle);
            }        
        }else{
            sameAngleCount = 0;
        }    
        lastAngle = currentAngle;   
    }  
    
    show_debug_message(scr_listToString(sampledShape));
    
    // The user drawn shape size
    shapeSize = ds_list_size(sampledShape);
    
    // Copy the shapes
    var shapesCopy; shapesCopy = ds_map_create(); 
    ds_map_copy(shapesCopy, shapes);
    
    // Remove the shapes that does not match what the user made
    var currentShapeIndex;
    var currentShape;
    
    // For each shape we handle
    for (currentShapeIndex = 0; currentShapeIndex &lt; shapesCount; currentShapeIndex += 1){
        currentShape = ds_map_find_value(shapesCopy, currentShapeIndex);
        // Different size, it's not the one
        if (ds_list_size(currentShape) != shapeSize){
            ds_map_delete(shapesCopy,currentShapeIndex);
            continue;
        }
        
        // Different angle, it's not the one
        for (currentAngleIndex = 0; currentAngleIndex &lt; shapeSize; currentAngleIndex += 1){
            if (ds_list_find_value(sampledShape,currentAngleIndex) != ds_list_find_value(currentShape,currentAngleIndex)){
                ds_map_delete(shapesCopy,currentShapeIndex);
                break;
            }        
        }    
    }
    
    var size; size = ds_list_size(allX);
    
    if (ds_map_size(shapesCopy) == 1 &amp;&amp; size &gt; 0){
        // One shape fount !
        
        
        // Compute the event position and size
        var i, minX, maxX, minY, maxY, curX, curY, sumX, sumY; 
           
        sumX = 0;
        sumY = 0;
        minX = room_width;
        maxX = 0;
        minY = room_height;
        maxY = 0;
        
        for (i = 0; i &lt; size; i += 1){
            curX = ds_list_find_value(allX, i);
            curY = ds_list_find_value(allY, i);      
            sumX += curX;
            sumY += curY;
            minX = min(minX, curX);
            minY = min(minY, curY);
            maxX = max(maxX,curX);
            maxY = max(maxY,curY);
        }
                      
        with(obj_player){
            obj_player.eventX = sumX / size;
            obj_player.eventY = sumY / size;
            obj_player.eventWidth = maxX - minX;
            obj_player.eventHeight = maxY - minY;
            event_user(ds_map_find_first(shapesCopy));
        }
    }else{
        show_debug_message("No match found");
    }
    
    ds_map_destroy(shapesCopy);
    ds_list_destroy(sampledShape);
}
 
// Reset the controller
ds_queue_clear(pointsX);
ds_queue_clear(pointsY); 
ds_list_clear(allX);
ds_list_clear(allY);
ds_list_clear(shape); 
move = false;
samePointCount = 0;

with(obj_player){
    // move end
    event_user(14);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize input
show_debug_message("Pressed");
//move = false;
//samePointCount = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Compute the user mouse mouvement
show_debug_message("Button");

// The player is moving EDE, no need to compute angles anymore
if (move){
    with(obj_player){
        event_user(15);
    }
    exit;
}

// Compute angles made by the user mouse mouvement
var pointX; pointX = round(mouse_x / CTRL_POINT_GRID);
var pointY; pointY = round(mouse_y / CTRL_POINT_GRID);

// Empty queue =&gt; add the point and exit !
if (ds_queue_empty(pointsX)){
    ds_queue_enqueue(pointsX,pointX);
    ds_queue_enqueue(pointsY,pointY);
    ds_list_add(allX, mouse_x);
    ds_list_add(allY, mouse_y);
    exit;
}

// Check if point is already in the queue
var lastX; lastX = ds_queue_tail(pointsX);
var lastY; lastY = ds_queue_tail(pointsY);
if (pointX == lastX &amp;&amp; pointY == lastY){
    // Count the number of time we hit the same point
    samePointCount += 1;
    if (samePointCount &gt;= CTRL_MOVE_COUNT){
        // Now we are moving !
        move = true;
        ds_list_clear(allX);
        ds_list_clear(allY);
        with(obj_player){
            event_user(15);
        }
    }    
    // Nothing to do here    
    exit;
}

// Add the point
ds_queue_enqueue(pointsX, pointX);
ds_queue_enqueue(pointsY, pointY);
ds_list_add(allX, mouse_x);
ds_list_add(allY, mouse_y);
if (ds_queue_size(pointsX) &gt; CTRL_POINTS_COUNT){
    ds_queue_dequeue(pointsX);
    ds_queue_dequeue(pointsY);
}

// Get the cmp of the queue
var cmpX; cmpX = ds_queue_head(pointsX);
var cmpY; cmpY = ds_queue_head(pointsY);

var sampledAngle; sampledAngle = scr_sampleAngle(point_direction(cmpX,cmpY,pointX,pointY))

ds_list_add(shape,sampledAngle); 

//show_debug_message("["+string(pointX)+","+string(pointY)+"] and ["+string(cmpX)+","+string(cmpY)+"] =&gt;"+string(sampledAngle));

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the "line" of the shape


if (!ds_list_empty(allX)){
    draw_set_color(make_color_rgb(25,201,255));    
    draw_set_alpha(0.5);    
    
    var i, size, curX, curY, offset; 
    size = ds_list_size(allX);
            
    draw_primitive_begin(pr_trianglestrip);    
    for (i = 0; i &lt; size; i += 1){
        curX = ds_list_find_value(allX, i);
        curY = ds_list_find_value(allY, i);      
        if (i == 0 || i == size - 1){
            draw_vertex(curX, curY);
        }else {
            if (i &lt; size /2){
                offset = 2 * i;           
            }else{      
                offset = 2 * abs(i - size);           
            }
            draw_vertex(curX - offset, curY - offset);
            draw_vertex(curX + offset, curY + offset);
        }
    }
    draw_primitive_end();
   
/*    for (i = 1; i &lt; size; i += 1){
        var curX, curY, prevX, prevY;
        curX = ds_list_find_value(allX, i);
        curY = ds_list_find_value(allY, i);
        prevX = ds_list_find_value(allX, i - 1);
        prevY = ds_list_find_value(allY, i - 1);
        draw_line_width_color(curX,curY,prevX,prevY,5,c_red,c_blue);     
        
    }*/
    
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
